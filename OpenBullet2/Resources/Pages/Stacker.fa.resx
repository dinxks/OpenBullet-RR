<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AvailableBlocks" xml:space="preserve">
    <value>بلوک های موجود</value>
  </data>
  <data name="BlockInformation" xml:space="preserve">
    <value>اطلاعات بلوک </value>
  </data>
  <data name="CurrentStack" xml:space="preserve">
    <value>استک جاری</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>استکر چیست؟?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>٪ استکر ها٪ ابزاری است که می تواند به شما کمک کند تنظیمات خود را به روشی کاملا کاربر پسند بسازید ، به لطف مفهوم٪ بلوک ها٪. بلوک ها نمایشی بصری از برخی دستورالعمل های لولی کد هستند ، و آنها اساساً توابعی هستند که می توانند در هر زمان خاص فراخوانی شوند ، به صورت اختیاری برخی از پارامترهای ورودی را گرفته و به صورت اختیاری برخی نتایج خروجی را تولید می کنند. ٪ استک٪ در واقع فقط لیستی از بلوک هایی است که توسط یک ربات ، یکی پس از دیگری از بالا به پایین اجرا می شوند.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>می توانید پشته را با٪ اضافه کردن٪ یا٪ حذف٪ بلوک ها ،٪ حرکت دادن آنها به بالا و پایین و٪ شبیه سازی٪ آنها تغییر دهید. اگر می خواهید از اجرای یک بلوک بدون نیاز به حذف آن و از بین رفتن تمام محتوای آن ، بلوک ها نیز٪ غیرفعال شود.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>بلوک ها به طور عمده با٪ نوشته  (که می توانید به دلخواه خود تنظیم کنید) و برخی تنظیمات که پارامترهای ورودی و نتایج خروجی هستند ، مشخص می شوند. اگر می خواهید کد C# را به پیکربندی خود اضافه کنید ، می بینید که هنگام بازگشت به نمای استکر ، برخی از٪ بلاک های لولی کد٪ ایجاد می شوند. این بلوک ها حاوی کدی هستند که تجزیه کننده لولی کد نمی تواند آنها را به عنوان بلوک های مناسب شناسایی کند ، به عنوان مثال حلقه ها و شرطی ها یا سایر عبارات C#.</value>
  </data>
  <data name="Help2x00" xml:space="preserve">
    <value>سیستم متغیرهای جدید</value>
  </data>
  <data name="Help2x01" xml:space="preserve">
    <value>٪ متغیرها در OB2 به طرز متفاوتی نسبت به OB1 کار می کنند. برای درک دلیل این تغییر ، باید بدانید که تنظیمات قبل از اجرا به C# منتقل می شوند و سپس برای سرعت کامپایل می شوند. سیستم OB1 هنگام اجرا از LoliScript تفسیر شد ، بنابراین سرعت آن بسیار کندتر بود. C # یک زبان به شدت تایپ شده است و از این رو متغیرها با یک نوع مرتبط هستند ، به عنوان مثال `int` برای اعداد صحیح و` رشته` برای رشته ها. در OB1 همه چیز یک رشته بود (یا لیستی از رشته ها یا فرهنگ نامه های رشته ها) اما در OB2 انواع دیگری وجود دارد.</value>
  </data>
  <data name="Help2x02" xml:space="preserve">
    <value>٪٪ متغیرهای OB2 می تواند باشد: Bool ، ByteArray ، فرهنگ رشته ها ، شناور ، Int ، لیست رشته ها ، رشته ها و Enum. متغیرها عمدتاً از طریق فیلد٪ متغیر خروجی٪ بلوک ها ایجاد می شوند که در مقدار مناسبی بلوک وجود دارد. این قسمت نوع متغیر ایجاد شده را به شما اطلاع می دهد. این قسمت معمولاً با یک گزینه اضافی به نام٪ Is capture٪ همراه است که به ربات اجازه می دهد تا بداند متغیر خاصی باید ذخیره شود و در صورت برخورد به٪ داده های گرفته شده٪ نوشته شود.</value>
  </data>
  <data name="Help2x03" xml:space="preserve">
    <value>parameters پارامترهای ورودی٪ بلوک ها نیز مانند OB1 نوع خاصی دارند. بسته به نوع آنها می توانید از بین 3 حالت مختلف برای ورود داده ها به آن پارامترها انتخاب کنید. حالت٪ ثابت٪ به شما امکان می دهد مقدار ثابت را که برای هر اجرا همیشه یکسان است ، برای مثال "42" یا "سلام" تعیین کنید. حالت٪ متغیر٪ به شما امکان می دهد از یک متغیر ایجاد شده قبلی به عنوان مقدار ورودی برای آن پارامتر استفاده کنید. اگر مقدار اصلی با توجه به نوع پارامتر از نوع دیگری باشد ، به طور خودکار برای شما تبدیل می شود (به عنوان مثال اگر یک عدد صحیح داشته باشید و سعی کنید آن را به یک پارامتر رشته منتقل کنید ، به طور خودکار به عنوان یک رشته خوانده می شود) )</value>
  </data>
  <data name="Help2x04" xml:space="preserve">
    <value>سرانجام ، حالت٪ interpolated٪ بسیار نزدیک به نحوه کار در OB1 است ، جایی که می توانید از نحو استفاده کنید "here is my &amp; lt؛ variable &amp; gt؛" ، جایی که "variable" نام متغیری است که می خواهید داخل آن قرار دهید رشته این حالت فقط برای پارامترهای String ، List of String و فرهنگ لغت در دسترس است.</value>
  </data>
  <data name="Help3x00" xml:space="preserve">
    <value>متغیرهای پیش فرض</value>
  </data>
  <data name="Help3x01" xml:space="preserve">
    <value>برخی از متغیرها قبلاً برای شما اعلام شده اند و می توان از آنها برای دسترسی به داده های ورودی و خصوصیات رزرو شده استفاده کرد. متغیر «input» یک شی پویا است که شامل داده های قطعه قطعه شده از مجموعه داده های شما است (به عنوان مثال اگر از نوع لیست کلمات پیش فرض استفاده می کنید ، می توانید به «input.DATA» دسترسی پیدا کنید تا خط داده خود را بازیابی کنید) و پاسخ ورودی های سفارشی که در زمان اجرا از آنها سال می شود.</value>
  </data>
  <data name="Help3x02" xml:space="preserve">
    <value>شی `data` یک کلاس با چندین ویژگی است که به طور خودکار توسط بلوک ها پر می شوند اما می توانید از آنها به عنوان متغیرهای خروجی برای سایر بلوک ها استفاده کنید. مفیدترین آنها STATUS ، SOURCE ، RAWSOURCE ، ADDRESS ، RESPONSECODE ، COOKIES و HEADERS هستند. به عنوان مثال ، برای استفاده از منبع پاسخ HTTP به عنوان یک پارامتر ورودی از یک بلوک تجزیه ، باید حالت متغیر را انتخاب کنید و "data.SOURCE" را در جعبه تایپ کنید.</value>
  </data>
  <data name="Help3x03" xml:space="preserve">
    <value>شی `« داده »شامل متغیرهای بسیار مفیدتری است (مانند پروکسی) که می تواند از طریق کد C # برای انجام برخی رفتارهای پیشرفته دستکاری شود. آنها در یک راهنمای جداگانه پوشش داده خواهد شد.
سرانجام شی `` globals` شامل متغیرهای جهانی است و بین ربات ها به اشتراک گذاشته می شود. شما می توانید متغیرهای جهانی را با استفاده از چیزی مانند `globals.Test` به عنوان متغیر خروجی تنظیم کنید و برای بازیابی مقدار آن از همین طریق استفاده کنید. اگر می خواهید روی آن عملیات طولانی انجام دهید ، به عنوان مثال با لیست های جهانی موارد کار کنید ، باید٪ را بر روی شی object "globals" با "قفل (globals)" قفل کنید {بلوک ها و کد خود را در اینجا} "تا از نظر موضوعی ایمن باشد .</value>
  </data>
  <data name="NoBlockSelectedInfo" xml:space="preserve">
    <value>برای نمایش تنظیمات آن ، یک بلوک را انتخاب کنید</value>
  </data>
</root>