<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AvailableBlocks" xml:space="preserve">
    <value>Bloques disponibles</value>
  </data>
  <data name="BlockInformation" xml:space="preserve">
    <value>Información de bloque</value>
  </data>
  <data name="CurrentStack" xml:space="preserve">
    <value>Pila actual</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>¿Qué es Pila ó Stacker?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>%Pila ó Stacker% es una herramienta que puede ayudarte a construir tus configuraciones de una manera muy fácil de usar, gracias al concepto de %bloques%. Los bloques son una representación visual de algunas directivas de LoliCode, y básicamente son funciones que se pueden llamar en cualquier momento dado, opcionalmente tomando algunos parámetros de entrada y, opcionalmente, produciendo algunos resultados de salida. La %Pila ó Stack% es básicamente una lista de bloques que un bot ejecutará, uno tras otro, de arriba a abajo.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>Puede modificar la pila %agregando% ó %eliminando% bloques, %moviéndolos hacia arriba y hacia abajo% y %clonándolos%. Los bloques también se pueden %deshabilitar% si desea omitir la ejecución de un bloque sin tener que eliminarlo y, por lo tanto, perder todo su contenido.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>Los bloques se caracterizan principalmente por una %etiqueta% (que puede personalizar a su gusto) y por algunos ajustes que son los parámetros de entrada y los resultados de salida. Si desea agregar código C # a su configuración, verá que se crearán algunos %bloques de LoliCode% cuando regrese a la vista Pila / Stacker. Estos bloques contienen código que el analizador LoliCode no pudo identificar como bloques adecuados, por ejemplo, bucles, condicionales u otras expresiones de C #.</value>
  </data>
  <data name="Help2x00" xml:space="preserve">
    <value>Nuevo sistema de variables</value>
  </data>
  <data name="Help2x01" xml:space="preserve">
    <value>%Variables% en OB2 funcionan de una manera muy diferente que en OB1. Para comprender la razón detrás de este cambio, debe saber que las config se transpilan a C # y luego se compilan para mayor velocidad antes de ejecutarse. El sistema OB1 se interpreta desde LoliScript en tiempo de ejecución, por lo que era mucho más lento. C # es un lenguaje fuertemente tipado y, por lo tanto, las variables están asociadas con un tipo, por ejemplo, `int` para enteros y` string` para textos. En OB1 todo era un texto (o lista de textos, o diccionarios de textos) pero en OB2 hay tipos adicionales.</value>
  </data>
  <data name="Help2x02" xml:space="preserve">
    <value>El %tipo% de una variable en OB2 puede ser: Verdadero ó falso (Bool), arreglo de bites (ByteArray), Diccionario de texto (strings), Float, integro (Int), Lista de textos (strings), Texto y Enum. Las variables se crean principalmente a través del campo en bloques %Salida de Variable%, que está presente en una gran cantidad de bloques. Este campo le permitirá conocer el tipo de variable que se creará. Este campo generalmente viene con una opción adicional llamada %es captura%, que le permite al bot saber que una variable específica debe guardarse y escribirse en %Captura de Datos% si obtiene un resultado.</value>
  </data>
  <data name="Help2x03" xml:space="preserve">
    <value>%Parámetros de entrada% de bloques también tienen un tipo específico, como en OB1. Puede elegir entre hasta 3 modos diferentes para ingresar datos en esos parámetros, dependiendo de su tipo. El modo %fijo% le permite especificar un valor fijo que es siempre el mismo para cada ejecución, por ejemplo, `42` ó` hola`. El modo %variable% le permite utilizar una variable creada previamente como valor de entrada para ese parámetro. Si el valor original es de un tipo diferente con respecto al tipo de parámetro, se convertirá automáticamente para usted (por ejemplo, si tiene un número entero e intenta pasarlo a un parámetro de texto, se leerá automáticamente como un texto).</value>
  </data>
  <data name="Help2x04" xml:space="preserve">
    <value>Finalmente, el modo %interpolado% que es muy parecido a cómo funcionó en OB1, donde puede usar la sintaxis `aquí está mi &lt;variable&gt;`, donde `variable` es el nombre de la variable que desea insertar dentro del texto. Este modo solo está disponible para los parámetros de Texto, Lista de textos y Diccionario de texto.</value>
  </data>
  <data name="Help3x00" xml:space="preserve">
    <value>Variables predeterminadas</value>
  </data>
  <data name="Help3x01" xml:space="preserve">
    <value>Algunas variables ya están declaradas para usted y pueden usarse para acceder a datos de entrada y propiedades reservadas. La variable `input` es un objeto dinámico que contiene los datos individuales de su grupo de datos (por ejemplo, si está utilizando el tipo de diccionario predeterminado, podrá acceder a` input.DATA` para recuperar su línea de datos) y las respuestas de las entradas personalizadas que se preguntan en tiempo de ejecución.</value>
  </data>
  <data name="Help3x02" xml:space="preserve">
    <value>El objeto `data` es una clase con múltiples propiedades que se llenan automáticamente con bloques pero que también puedes usar como variables de salida para otros bloques. Los más útiles son STATUS, SOURCE, RAWSOURCE, ADDRESS, RESPONSECODE, COOKIES y HEADERS. Por ejemplo, para utilizar el origen de una respuesta HTTP como parámetro de entrada de un bloque de análisis, deberá seleccionar el modo variable y escribir "data.SOURCE" en el cuadro.</value>
  </data>
  <data name="Help3x03" xml:space="preserve">
    <value>El objeto `data` contiene muchas más variables útiles (como el Proxy) que se pueden manipular a través del código C # para realizar algún comportamiento avanzado. Esto se cubrirán en una guía separada.
Finalmente, el objeto `globals` contiene variables globales y se comparten entre los bots. Puede establecer variables globales usando algo como `globals.Test` como variable de salida, y lo mismo para recuperar su valor. Si planeas realizar operaciones largas en él, por ejemplo, trabajando con listas globales de elementos, debes %bloquear% en el objeto `globals` con` lock (globals) {Tu bloque y código aquí} `para que sea seguro para los subprocesos.</value>
  </data>
  <data name="NoBlockSelectedInfo" xml:space="preserve">
    <value>Seleccione un bloque para mostrar sus ajustes</value>
  </data>
</root>