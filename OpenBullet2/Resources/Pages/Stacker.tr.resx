<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AvailableBlocks" xml:space="preserve">
    <value>Mevcut bloklar</value>
  </data>
  <data name="BlockInformation" xml:space="preserve">
    <value>Blok bilgisi</value>
  </data>
  <data name="CurrentStack" xml:space="preserve">
    <value>Mevcut yığın</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>Yığınlayıcı/Stacker nedir?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>%Yığınlayıcı/Stacker%, %bloklar% konsepti sayesinde yapılandırmalarınızı oldukça kullanıcı dostu bir şekilde oluşturmanıza yardımcı olabilecek bir araçtır. Bloklar, bazı LoliCode direktiflerinin görsel temsilleridir ve temelde herhangi bir zamanda çağrılabilen, isteğe bağlı olarak bazı girdi parametrelerini alan ve isteğe bağlı olarak bazı çıktı sonuçları üreten işlevlerdir. %Yığın/Stack% temelde bir bot tarafından yukarıdan aşağıya birbiri ardına yürütülecek blokların bir listesidir.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>Yığını %ekleyerek% veya blok %silerek%, bunları %yukarı ve aşağı hareket ettirerek% veya %klonlayarak% değiştirebilirsiniz. Bir bloğun yürütülmesini kaldırmak zorunda kalmadan ve dolayısıyla tüm içeriğini kaybetmeden atlamak isterseniz, bloklar %devre dışı% bırakılabilir.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>Bloklar temel olarak bir %etiketi% (istediğiniz gibi özelleştirebilirsiniz) ve girdi parametreleri ve çıktı sonuçları olan bazı ayarlarla karakterize edilir. Yapılandırmanıza C# kodu eklemek isterseniz, Yığınlayıcı görünümüne geri döndüğünüzde bazı %Lolikod bloklarının% oluşturulacağını göreceksiniz. Bu bloklar, LoliCode ayrıştırıcısının uygun bloklar olarak tanımlayamadığı kodu içerir, örneğin döngüler ve koşullu ifadeler veya diğer C # ifadeleri.</value>
  </data>
  <data name="Help2x00" xml:space="preserve">
    <value>Yeni variables/değişkenler sistemi</value>
  </data>
  <data name="Help2x01" xml:space="preserve">
    <value>OB2'de %Değişkenler% OB1'de olduğundan çok daha farklı bir şekilde çalışır. Bu değişikliğin arkasındaki nedeni anlamak için, yapılandırmaların C#'ye aktarıldığını ve ardından yürütülmeden önce hız için derlendiğini bilmelisiniz. OB1 sistemi çalışma zamanında LoliScript'ten yorumlandı, bu yüzden çok daha yavaştı. C# türü kesin olarak belirlenmiş bir dildir ve bu nedenle değişkenler bir türle ilişkilidir, örneğin tamsayılar için `int` dizeler için `string`. OB1'de her şey bir dizeydi (veya dizeler listesi veya dize sözlükleri), ancak OB2'de ek türler vardır.</value>
  </data>
  <data name="Help2x02" xml:space="preserve">
    <value>Bir OB2 değişkeninin %tip% değeri şunlar olabilir: Bool, ByteArray, Dizeler Sözlüğü, Float, Int, Dizeler Listesi, Dize/String ve Enum. Değişkenler, temelde blokların %Çıktı değişkeni% alanı aracılığıyla oluşturulur ve bu alan iyi miktarda blok içinde bulunur. Bu alan, oluşturulacak değişkenin türünü size bildirecektir. Bu alan genellikle %Is capture% adında ek bir seçenekle birlikte gelir ve bu, botun belirli bir değişkenin kaydedilmesini sağlar ve bir Hit/Bulunan Kayıt alırsanız, %Yakalanan Veri/Captured Data%'ye yazılması gerektiğini bilmesini sağlar.</value>
  </data>
  <data name="Help2x03" xml:space="preserve">
    <value>Blokların %Giriş Parametreleri% OB1'de olduğu gibi belirli bir türe sahiptir. Türlerine bağlı olarak, bu parametrelere veri girmek için 3 farklı mod arasından seçim yapabilirsiniz. %Fixed/Sabit% her yürütme için her zaman aynı olan sabit bir değer belirlemenize olanak tanır, örneği `42` veya `merhaba`. %Değişken/variable% modu önceden oluşturulmuş bir değişkeni o parametre için girdi değeri olarak kullanmanıza izin verir. Orijinal değer, parametre türüne göre farklı bir türdeyse, sizin için otomatik olarak dönüştürülür (örneğin, bir tamsayınız varsa ve onu bir dize parametresine geçirmeye çalışırsanız, otomatik olarak bir dize olarak okunur).</value>
  </data>
  <data name="Help2x04" xml:space="preserve">
    <value>Son olarak, %enterpolasyonlu/interpolated% modu OB1'de nasıl çalıştıysa ona çok yakındır, `here is my &lt;variable&gt;` sözdizimini kullanabileceğiniz, burada`değişken/variable` içine eklemek istediğiniz dizenin adıdır. Bu mod yalnızca String 'dize', List of String 'dize listesi' ve Dictionary of String 'dize sözlüğü' parametreleri için kullanılabilir.</value>
  </data>
  <data name="Help3x00" xml:space="preserve">
    <value>Varsayılan değişkenler</value>
  </data>
  <data name="Help3x01" xml:space="preserve">
    <value>Bazı değişkenler sizin için zaten tanımlanmıştır, giriş verilerine ve ayrılmış özelliklere erişmek için kullanılabilirler. `input` değişkeni veri havuzunuzdaki dilimlenmiş verileri içeren dinamik bir nesnedir (örneğin, Varsayılan kelime listesi/wordlist türünü kullanıyorsanız, veri hattınızı almak için `input.DATA` 'ya erişebileceksiniz) ve çalışma zamanında sorulan özel girdilerin yanıtlarını alacaksınız.</value>
  </data>
  <data name="Help3x02" xml:space="preserve">
    <value>`Veri` nesnesi bloklar tarafından otomatik olarak doldurulan, ancak diğer bloklar için çıktı değişkenleri olarak da kullanabileceğiniz birden çok özelliğe sahip bir sınıftır. En kullanışlı olanlar STATUS/Durum, SOURCE/Kaynak RAWSOURCE/Hamkaynak, ADDRESS/Adres, RESPONSECODE/Yanıt kodu, COOKIES/Çerezler ve HEADERS/Üstbilgiler'dir. Örneğin, bir HTTP yanıtının kaynağını bir ayrıştırma bloğunun giriş parametresi olarak kullanmak için, değişken modunu seçmeniz ve kutuya `data.SOURCE` yazmanız gerekir.</value>
  </data>
  <data name="Help3x03" xml:space="preserve">
    <value>`Veri` nesnesi bazı gelişmiş hareketleri gerçekleştirmek için C# kodu aracılığıyla işlenebilen çok daha yararlı değişkenler (Proksi gibi) içerir. Ayrı bir kılavuzda ele alınacaktır.
Son olarak `globals` nesnesi nesnesi global değişkenler içerir ve botlar arasında paylaşılır. Global değişkenleri, çıktı değişkeni olarak `globals.Test` gibi bir şey kullanarak ve değerini almak için aynı şekilde ayarlayabilirsiniz. Üzerinde uzun işlemler yapmayı planlıyorsanız, örneğin global öğe listesiyle çalışıyorsanız başlığı güvenli hale getirmek için `lock(globals) { your blocks and code here }` nesnesine %kilitlenmelisiniz%.</value>
  </data>
  <data name="NoBlockSelectedInfo" xml:space="preserve">
    <value>Ayarlarda görüntülemek için bir blok seçin</value>
  </data>
</root>