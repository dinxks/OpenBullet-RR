<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AvailableBlocks" xml:space="preserve">
    <value>Beschikbare blokken</value>
  </data>
  <data name="BlockInformation" xml:space="preserve">
    <value>Blok informatie</value>
  </data>
  <data name="CurrentStack" xml:space="preserve">
    <value>Huidige stapel</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>Wat is een Stapelaar?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>%Stapelaar% is een tool die u kan helpen bij het bouwen van uw configs op een zeer gebruiksvriendelijke manier, dankzij het concept van %blokken%. Blokken zijn een visuele weergave van sommige LoliCode-richtlijnen, en het zijn in feite functies die op elk moment kunnen worden aangeroepen, waarbij optioneel enkele invoerparameters kunnen worden gebruikt en optioneel enkele uitvoerresultaten kunnen worden geproduceerd. De %Stapel% is eigenlijk gewoon een lijst met blokken die door een bot worden uitgevoerd, de een na de ander van boven naar beneden.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>U kunt de stapel wijzigen door %toe te voegen% of %blokken te verwijderen%, %ze op en neer te bewegen% en %te dupliceren% ze. Blokken kunnen ook %uitgeschakeld% worden als u de uitvoering van een blok wilt overslaan zonder het te hoeven verwijderen en daardoor de volledige inhoud verliest.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>Blokken worden voornamelijk gekenmerkt door een %label% (die u naar wens kunt aanpassen) en door enkele instellingen die de invoerparameters en de uitvoerresultaten zijn. Als je C #-code aan je config wilt toevoegen, zul je zien dat enkele %LoliCode-blokken% zullen worden aangemaakt als je teruggaat naar de Stapelaar-weergave. Deze blokken bevatten code die de LoliCode-parser niet als juiste blokken kon identificeren, bijvoorbeeld loops en conditionals of andere C#-uitdrukkingen.</value>
  </data>
  <data name="Help2x00" xml:space="preserve">
    <value>Het nieuwe variabelenstelsel</value>
  </data>
  <data name="Help2x01" xml:space="preserve">
    <value>%Variabelen% in OB2 werken op een veel andere manier dan in OB1. Om de reden achter deze wijziging te begrijpen, moet u weten dat configs naar C# worden getransporteerd en vervolgens voor snelheid worden gecompileerd voordat ze worden uitgevoerd. OB1-systeem werd tijdens runtime geïnterpreteerd vanuit LoliScript, dus het was veel langzamer. C# is een sterk getypeerde taal en daarom zijn variabelen geassocieerd met een type, bijvoorbeeld 'int' voor gehele getallen en 'string' voor strings. In OB1 was alles een string (of lijst met strings, of woordenboeken met strings), maar in OB2 zijn er nog meer typen.</value>
  </data>
  <data name="Help2x02" xml:space="preserve">
    <value>Het %type% van een OB2-variabele kan zijn: Bool, ByteArray, Dictionary of Strings, Float, Int, List of Strings, String en Enum. Variabelen worden voornamelijk gemaakt via het veld %Uitvoervariabele% met blokken, dat in een groot aantal blokken aanwezig is. Dit veld laat u weten welk type variabele zal worden gemaakt. Dit veld wordt meestal geleverd met een extra optie genaamd %Is capture%, die de bot laat weten dat een specifieke variabele moet worden opgeslagen en naar de %Captured Data% moet worden geschreven als je een hit krijgt.</value>
  </data>
  <data name="Help2x03" xml:space="preserve">
    <value>%Invoerparameters% van de blokken hebben ook een specifiek type, zoals in OB1. U kunt kiezen uit maximaal 3 verschillende types voor het invoeren van gegevens in die parameters, afhankelijk van hun type. Met de %fixed%-modus kunt u een vaste waarde specificeren die altijd hetzelfde is voor elke uitvoering, bijvoorbeeld '42' of 'hallo'. Met de %variable%-modus kunt u een eerder gemaakte variabele gebruiken als invoerwaarde voor die parameter. Als de oorspronkelijke waarde van een ander type is met betrekking tot het parametertype, wordt deze automatisch voor u geconverteerd (als u bijvoorbeeld een geheel getal heeft en u probeert deze door te geven aan een stringparameter, wordt deze automatisch gelezen als een string).</value>
  </data>
  <data name="Help2x04" xml:space="preserve">
    <value>Ten slotte komt de %geïnterpoleerde%-modus heel dicht bij hoe deze werkte in OB1, waar u de syntax kunt gebruiken `hier is mijn &lt;variabele&gt;`, waar `variabele` is de naam van de variabele die u in de string wilt invoegen. Deze modus is alleen beschikbaar voor de parameters String, List of String en Dictionary of String.</value>
  </data>
  <data name="Help3x00" xml:space="preserve">
    <value>Standaard variabelen</value>
  </data>
  <data name="Help3x01" xml:space="preserve">
    <value>Sommige variabelen zijn al voor u gedeclareerd en kunnen worden gebruikt om toegang te krijgen tot invoergegevens en gereserveerde eigenschappen. De `input` variabele is een dynamisch object dat de gesegmenteerde data uit je datapool bevat (als je bijvoorbeeld het Default wordlist type gebruikt, heb je toegang tot` input.DATA` om je datalijn op te halen) en de antwoorden van de aangepaste invoer die tijdens runtime wordt gevraagd.</value>
  </data>
  <data name="Help3x02" xml:space="preserve">
    <value>Het `data` -object is een klasse met meerdere eigenschappen die automatisch worden gevuld door blokken maar die je ook kunt gebruiken als uitvoervariabelen voor andere blokken. De meest bruikbare zijn STATUS, SOURCE, RAWSOURCE, ADRES, RESPONSECODE, COOKIES en HEADERS. Als u bijvoorbeeld de bron van een HTTP-antwoord als invoerparameter van een ontleedblok wilt gebruiken, moet u de variabele modus selecteren en 'data.SOURCE' typen in het vak.</value>
  </data>
  <data name="Help3x03" xml:space="preserve">
    <value>Het `data` -object bevat veel meer bruikbare variabelen (zoals de proxy) die kunnen worden gemanipuleerd via C # -code om wat geavanceerd gedrag uit te voeren. Ze worden behandeld in een aparte gids.
Ten slotte bevat het `globals` -object globale variabelen en wordt het gedeeld tussen bots. U kunt globale variabelen instellen door zoiets als 'globals.Test' als uitvoervariabele te gebruiken, en hetzelfde om de waarde ervan op te halen. Als u van plan bent er lange bewerkingen op uit te voeren, bijvoorbeeld werken met globale lijsten met items, moet u% lock% op het `globals` object met` lock (globals) {your blocks and code here} `om het thread-safe te maken .</value>
  </data>
  <data name="NoBlockSelectedInfo" xml:space="preserve">
    <value>Selecteer een blok om zijn instellingen weer te geven</value>
  </data>
</root>