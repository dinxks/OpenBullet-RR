<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AccessExpiration" xml:space="preserve">
    <value>Expiration de l'accès</value>
  </data>
  <data name="Add" xml:space="preserve">
    <value>Ajouter</value>
  </data>
  <data name="AddGuest" xml:space="preserve">
    <value>Ajouter un invité</value>
  </data>
  <data name="AllowedAddresses" xml:space="preserve">
    <value>Adresses autorisées</value>
  </data>
  <data name="AreYouSure" xml:space="preserve">
    <value>Êtes-vous sûr?</value>
  </data>
  <data name="Cancel" xml:space="preserve">
    <value>Annuler</value>
  </data>
  <data name="Delete" xml:space="preserve">
    <value>Supprimer</value>
  </data>
  <data name="EditGuest" xml:space="preserve">
    <value>Modifier l'invité</value>
  </data>
  <data name="EditInfo" xml:space="preserve">
    <value>Modifier les informations</value>
  </data>
  <data name="EditPassword" xml:space="preserve">
    <value>Modifier le mot de passe</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>Comment ça marche?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>OpenBullet 2 vous permet de créer des comptes pour des %invités% souhaitant accéder à votre serveur OpenBullet 2. Tout d'abord, n'oubliez pas d'activer l'option %Nécessite l'authentification administrateur% dans les %paramètres de sécurité% d'OB. Cela garantira que les personnes ayant le lien vers ce serveur seront accueillies avec un écran de connexion. Pour que d'autres personnes puissent accéder à ce serveur, vous devrez %ouvrir les ports% sur votre routeur et configurer les %règles de pare-feu% sur votre machine. Cela est généralement déjà fait pour vous sur un VPS, ce qui est la manière suggérée d'héberger une installation OpenBullet 2 exposée publiquement.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>Dans les %paramètres de sécurité%, vous pourrez également définir le %durée de vie de la session invité%, qui est le nombre d'heures après lequel les invités seront invités à se connecter à nouveau. Ceci est utile car vous ne voudrez peut-être pas que les invités aient un accès indéfini au serveur. Notez qu'une fois que le serveur a généré un %token% valide pour l'invité, il sera valide jusqu'à son expiration, donc même si vous supprimez un invité du tableau ci-dessus, il pourra utiliser votre installation OpenBullet 2 aussi longtemps que le le token est valide.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>En cliquant sur le bouton %Ajouter% ci-dessus, vous serez en mesure de créer %identifiants de connexion% pour le nouvel invité, définir le %expiration d'accès% (après quoi le serveur n'enverra plus de token valide à l'invité) et éventuellement configurer un certain nombre %d'adresses IP% à partir desquelles l'invité est autorisé à se connecter Ceci est utile pour empêcher les invités de partager leur compte avec d'autres personnes.</value>
  </data>
  <data name="Loading" xml:space="preserve">
    <value>Chargement</value>
  </data>
  <data name="NewPasswordForGuest" xml:space="preserve">
    <value>Nouveau mot de passe pour l'invité</value>
  </data>
  <data name="NoGuestSelectedWarning" xml:space="preserve">
    <value>Vous devez d'abord sélectionner un inviter</value>
  </data>
  <data name="NoRecordsToDisplay" xml:space="preserve">
    <value>Aucun enregistrement à afficher</value>
  </data>
  <data name="ReallyDelete" xml:space="preserve">
    <value>Voulez-vous vraiment supprimer?</value>
  </data>
  <data name="DeleteEverything" xml:space="preserve">
    <value>Voulez-vous vraiment tout supprimer?</value>
  </data>
  <data name="DeleteEverythingMessage" xml:space="preserve">
    <value>Voulez-vous vraiment tout supprimer ?</value>
  </data>
  <data name="results" xml:space="preserve">
    <value>Résultats</value>
  </data>
  <data name="ResultsPerPage" xml:space="preserve">
    <value>Résultats par page</value>
  </data>
  <data name="Uh-Oh" xml:space="preserve">
    <value>Uh-Oh</value>
  </data>
  <data name="Username" xml:space="preserve">
    <value>Nom d'utilisateur</value>
  </data>
</root>
