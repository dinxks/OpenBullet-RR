<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AvailableBlocks" xml:space="preserve">
    <value>Доступные блоки</value>
  </data>
  <data name="BlockInformation" xml:space="preserve">
    <value>Информация о блоке</value>
  </data>
  <data name="CurrentStack" xml:space="preserve">
    <value>Текущий стек</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>Что такое штабелер?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>%Stacker% - это инструмент, который поможет вам создавать конфигурации очень удобным для пользователя способом, благодаря концепции %blocks%. Блоки - это визуальное представление некоторых директив LoliCode, и по сути это функции, которые могут быть вызваны в любой момент времени, по желанию принимая некоторые входные параметры, и по желанию производя некоторые выходные результаты. Стек %Stack% - это, по сути, просто список блоков, которые будут выполняться ботом один за другим, сверху вниз.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>Вы можете изменять стек, %добавляя% или %удаляя% блоки, %перемещая их вверх и вниз% и %клонируя% их. Блоки также могут быть %отключены%, если вы хотите пропустить выполнение блока без необходимости его удаления и, следовательно, потери всего его содержимого.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>Блоки в основном характеризуются %label% (который вы можете настроить по своему усмотрению) и некоторыми параметрами, которые являются входными параметрами и выходными результатами. Если вы хотите добавить код на C# в свой конфиг, вы увидите, что при возвращении к представлению Stacker будут созданы некоторые блоки %LoliCode%. Эти блоки содержат код, который анализатор LoliCode не смог идентифицировать как правильные блоки, например, циклы и условия или другие выражения C#.</value>
  </data>
  <data name="Help2x00" xml:space="preserve">
    <value>Новая система переменных</value>
  </data>
  <data name="Help2x01" xml:space="preserve">
    <value>Переменные %Variables% в OB2 работают совсем не так, как в OB1. Чтобы понять причину этого изменения, вы должны знать, что конфигурации транслируются в C# и затем компилируются для скорости перед выполнением. Система OB1 интерпретировалась из LoliScript во время выполнения, поэтому она была намного медленнее. C# является сильно типизированным языком, и поэтому переменные связаны с типом, например `int` для целых чисел и `string` для строк. В OB1 все было строкой (или списком строк, или словарем строк), но в OB2 есть дополнительные типы.</value>
  </data>
  <data name="Help2x02" xml:space="preserve">
    <value>Тип %type% переменной OB2 может быть: Bool, ByteArray, Dictionary of Strings, Float, Int, List of Strings, String и Enum. Переменные создаются в основном через поле %Output variable% блоков, которое присутствует в большом количестве блоков. Это поле позволит вам узнать тип создаваемой переменной. Это поле обычно сопровождается дополнительной опцией %Is capture%, которая дает боту знать, что определенную переменную нужно сохранить и записать в %Captured Data% в случае попадания.</value>
  </data>
  <data name="Help2x03" xml:space="preserve">
    <value>%Входные параметры% блоков также имеют определенный тип, как в OB1. Вы можете выбрать один из трех различных режимов ввода данных в эти параметры в зависимости от их типа. Режим %fixed% позволяет задать фиксированное значение, которое всегда будет одинаковым при каждом выполнении, например, `42` или `hello`. Режим %variable% позволяет использовать ранее созданную переменную в качестве входного значения для данного параметра. Если исходное значение имеет другой тип по отношению к типу параметра, оно будет автоматически преобразовано (например, если у вас целое число и вы пытаетесь передать его в строковый параметр, оно будет автоматически считано как строка).</value>
  </data>
  <data name="Help2x04" xml:space="preserve">
    <value>Наконец, режим %interpolated% очень близок к тому, как он работал в OB1, где вы можете использовать синтаксис `here is my &lt;variable&gt;`, где `variable` - это имя переменной, которую вы хотите вставить внутрь строки. Этот режим доступен только для параметров String, List of String и Dictionary of String.</value>
  </data>
  <data name="Help3x00" xml:space="preserve">
    <value>Переменные по умолчанию</value>
  </data>
  <data name="Help3x01" xml:space="preserve">
    <value>Некоторые переменные уже объявлены за вас, и их можно использовать для доступа к входным данным и зарезервированным свойствам. Переменная `input` - это динамический объект, который содержит нарезанные данные из вашего пула данных (например, если вы используете тип Default wordlist, вы сможете обратиться к `input.DATA` для получения вашей строки данных) и ответы на пользовательские запросы, которые задаются во время выполнения.</value>
  </data>
  <data name="Help3x02" xml:space="preserve">
    <value>Объект `data` - это класс с несколькими свойствами, которые автоматически заполняются блоками, но которые вы также можете использовать в качестве выходных переменных для других блоков. Наиболее полезными из них являются STATUS, SOURCE, RAWSOURCE, ADDRESS, RESPONSECODE, COOKIES и HEADERS. Например, чтобы использовать источник HTTP-ответа в качестве входного параметра блока разбора, нужно выбрать режим переменной и ввести в поле `data.SOURCE`.</value>
  </data>
  <data name="Help3x03" xml:space="preserve">
    <value>Объект `data` содержит множество других полезных переменных (например, Proxy), которыми можно манипулировать с помощью кода C# для выполнения некоторых расширенных действий. Они будут рассмотрены в отдельном руководстве.
Наконец, объект `globals` содержит глобальные переменные и является общим для всех ботов. Вы можете установить глобальные переменные, используя что-то вроде `globals.Test` в качестве выходной переменной, и то же самое для получения ее значения. Если вы планируете выполнять длительные операции с ним, например, работать с глобальными списками элементов, вам следует %lock% на объект `globals` с помощью `lock(globals) { ваши блоки и код здесь }`, чтобы сделать его потокобезопасным.</value>
  </data>
  <data name="NoBlockSelectedInfo" xml:space="preserve">
    <value>Выберите блок, чтобы отобразить его настройки</value>
  </data>
</root>