<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AvailableBlocks" xml:space="preserve">
    <value>Blocchi disponibili</value>
  </data>
  <data name="BlockInformation" xml:space="preserve">
    <value>Informazione blocco</value>
  </data>
  <data name="CurrentStack" xml:space="preserve">
    <value>Stack corrente</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>Cos'è Stacker?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>%Stacker% è uno strumento che ti può aiutare a costruire le config in un modo molto user-friendly, grazie al concetto dei %blocchi%. I blocchi sono rappresentazioni visive di alcune direttive LoliCode, e sono essenzialmente delle funzioni che possono essere chiamate in qualsiasi momento, opzionalmente prendendo dei parametri in input, e sempre opzionalmente producendo dei risultati in output. Lo %Stack% è nient'altro che una lista di blocchi che saranno eseguiti da un bot, uno per uno dall'alto verso il basso.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>Puoi modificare lo stack %aggiungendo% o %rimuovendo% i blocchi, %spostandoli su e giù% e %duplicandoli%. I blocchi possono anche essere %disabilitati% se vuoi saltare l'esecuzione di un blocco senza rimuoverlo, in modo da evitare di perdere le sue informazioni.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>I blocchi sono caratterizzati principalmente da un %label% (che puoi personalizzare come preferisci) e alcune impostazioni che sono i parametri in input e i risultati in output. Se vuoi aggiungere codice C# alla tua config, vedrai che verranno generati dei %blocchi LoliCode% quando torni alla visualizzazione in Stacker. Questi blocchi contengono codice che il parser LoliCode non ha potuto identificare come veri e propri blocchi, per esempio espressioni condizionali, loop e altre espressioni C#.</value>
  </data>
  <data name="Help2x00" xml:space="preserve">
    <value>Il nuovo sistema di variabili</value>
  </data>
  <data name="Help2x01" xml:space="preserve">
    <value>Le %variabili% in OB2 funzionano in una maniera molto diversa da OB1. Per capire le ragioni dietro questo cambiamento, dovresti sapere che le config vengono tradotte in C# e poi compilate per avere maggiore velocità in fase di esecuzione. Il sistema di OB1 era interpretato da codice LoliScript al runtime, e per questo era molto più lento. Il C# è un linguaggio fortemente tipizzato e quindi a ogni variabile è associato un tipo, per esempio `int` per gli interi e `string` per le stringhe. In OB1 qualsiasi variabile era una stringa (o liste di stringhe, o dizionari di stringhe) ma in OB2 ci sono ulteriori tipi.</value>
  </data>
  <data name="Help2x02" xml:space="preserve">
    <value>Il %tipo% di una variabile di OB2 può essere: Bool, ByteArray, Dictionary of Strings, Float, Int, List of Strings, String and Enum. Le variabili sono create principalmente attraverso il campo %Output variable% dei blocchi, che è presente in un buon numero di blocchi. Questo campo ti permette di conoscere il tipo della variabile che verrà creata. Questo campo solitamente è accompagnato da un'altra opzione, %Is capture%, che fa capire al bot che una certa variabile deve essere salvata nei %Dati Catturati% quando trovi una hit.</value>
  </data>
  <data name="Help2x03" xml:space="preserve">
    <value>I %parametri di input% dei blocchi hanno anch'essi un tipo specifico, come in OB1. Puoi scegliere tra un massimo di 3 modalità di immissione dei dati in quei parametri, in base al loro tipo. La modalità %fissa% ti permette di specificare un valore che sarà sempre lo stesso per ogni esecuzione, come ad esempio `42` o `hello`. La modalità %variabile% ti permette di usare una variabile precedentemente creata come valore di input per quel parametro. Se il valore originale è di un tipo diverso da quello richiesto dal parametro, sarà convertito automaticamente (per esempio se hai un intero e provi a passarlo a un parametro che vuole una stringa, sarà automaticamente letto come una stringa).</value>
  </data>
  <data name="Help2x04" xml:space="preserve">
    <value>Infine, la modalità %interpolazione% è molto simile a come funzionava in OB1, dove puoi usare la sintassi `questa è la mia &lt;variabile&gt;`, dove `variabile` è il nome della variabile che vuoi inserire nella stringa. Questa modalità è disponibile solo per parametri di tipo stringa, o lista di stringhe, o dizionario di stringhe.</value>
  </data>
  <data name="Help3x00" xml:space="preserve">
    <value>Variabili predefinite</value>
  </data>
  <data name="Help3x01" xml:space="preserve">
    <value>Alcune variabili sono già dichiarate per te e possono essere usate per accedere ai dati di input e alle proprietà riservate. La variabile `input` è un oggetto dinamico che contiene i dati già separati dalla tua pool di dati (per esempio, se stai usando il tipo di wordlist Default, potrai accedere a `input.DATA` per ottenere la tua riga di dati) e le risposte agli input personalizzati che vengono domandati in fase di esecuzione.</value>
  </data>
  <data name="Help3x02" xml:space="preserve">
    <value>L'oggetto `data` è una classe con molte proprietà che vengono automaticamente riempite dai blocchi ma che puoi usare anche come variabili di output per altri blocchi. Le più utili sono STATUS, SOURCE, RAWSOURCE, ADDRESS, RESPONSECODE, COOKIES and HEADERS. Per esempio, per usare il sorgente di una risposta HTTP come parametro di input di un blocco Parse, dovrai selezionare la modalità di immissione %variabile% e scrivere `data.SOURCE` nella casella.</value>
  </data>
  <data name="Help3x03" xml:space="preserve">
    <value>L'oggetto `data` contiene molte altre variabili utile (come il Proxy) che possono essere manipolate attraverso il codice C# per compiere azioni avanzate. Queste saranno esplorate in una guida a parte.
Infine l'oggetto `globals` contiene le variabili globali ed è condiviso tra i bot. Puoi dichiarare variabili globali usando ad es. `globals.Test` come variabile di output, ed ottenere i valori con la medesima sintassi. Se hai in programma di eseguire operazioni lunghe sulle variabili globali, come ad esempio lavorare con liste globali di elementi, è opportuno apporre un %lock% all'oggetto `globals` tramite `lock(globals) { i tuoi blocchi e il tuo codice vanno qui }` in modo da renderlo thread-safe.</value>
  </data>
  <data name="NoBlockSelectedInfo" xml:space="preserve">
    <value>Seleziona un blocco per visualizzarne le impostazioni</value>
  </data>
</root>