<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AdvancedSettings" xml:space="preserve">
    <value>Ajustes avanzados</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>¿Cómo funciona este bloque?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>El bloque %HTTP Request% le permite realizar una solicitud HTTP hacia un destino. Si desea enviar datos junto con sus encabezados y cookies, puede hacerlo seleccionando una de las formas de enviar contenido. El modo %Standard% simplemente tomará un texto, lo codificará como UTF-8 y lo enviará dentro de los datos en la solicitud. El campo %Content Type% se convertirá automáticamente en un encabezado %Content-Type% y se agregará a la solicitud.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>El modo %Raw% básicamente hace lo mismo que el modo Estándar si su contenido es una matriz de bytes y no un texto. El %Basic Auth% se usa para autenticarse con la Autenticación de acceso básico (la ventana emergente típica de nombre de usuario / contraseña que se ve dentro de su navegador pidiendo credenciales). Finalmente, el modo %Multipart% enviará un contenido que puede estar compuesto por múltiples partes, como texto, bytes sin formato y archivos. Esto es útil, por ejemplo, para cargar un archivo en un sitio web.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>La respuesta se analizará y dividirá en fragmentos que se asignarán a diferentes variables predeterminadas. La respuesta %Address% (después de la última redirección si tiene %Auto Redirect% habilitado) se guardará en la variable de texto `data.ADDRESS`. La respuesta %body% (también conocida como fuente) estará dentro de la variable Texto `data.SOURCE` (como un texto UTF-8) y dentro de la variable Byte Array` data.RAWSOURCE` (después de la descompresión de por ejemplo, gzip).</value>
  </data>
  <data name="Help1x04" xml:space="preserve">
    <value>El %código de respuesta% (por ejemplo, 200) se insertará en una variable de tipo integro `data.RESPONSECODE`. Los encabezados se analizarán y se insertarán en la variable de tipo Diccionario (par) de Texto `data.HEADERS`, y también para las cookies en la variable` data.COOKIES`. Recuerde que puede recuperar fácilmente valores de diccionarios por clave con la sintaxis `data.HEADERS [" header-name "]`. Si la solicitud falla, la variable `data.STATUS` se establecerá en` ERROR`.</value>
  </data>
  <data name="Help1x05" xml:space="preserve">
    <value>Una última cosa para recordar es que las cookies dentro de la variable `data.COOKIES` solo se agregan ó sobrescriben, nunca se eliminan. Esto significa que las cookies recibidas anteriormente (que están dentro de la variable `data.COOKIES`) serán enviadas nuevamente dentro de las siguientes solicitudes, además del %Custom Cookies% que puedes definir para cada nueva solicitud. Esto sucederá a menos que se borre o reinicialice `data.COOKIES`.</value>
  </data>
  <data name="Hide" xml:space="preserve">
    <value>Ocultar</value>
  </data>
  <data name="Label" xml:space="preserve">
    <value>Etiqueta</value>
  </data>
  <data name="Settings" xml:space="preserve">
    <value>Ajustes</value>
  </data>
  <data name="Show" xml:space="preserve">
    <value>Mostrar</value>
  </data>
</root>