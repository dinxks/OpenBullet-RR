<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AdvancedSettings" xml:space="preserve">
    <value>Réglages avancés</value>
  </data>
  <data name="Help1x00" xml:space="preserve">
    <value>Comment fonctionne ce bloc?</value>
  </data>
  <data name="Help1x01" xml:space="preserve">
    <value>Le bloc %HTTP Request% vous permet d'effectuer une requête HTTP vers un point de terminaison. Si vous souhaitez envoyer un corps à côté de vos en-têtes et cookies, vous pouvez le faire en sélectionnant l'un des moyens d'envoyer du contenu. Le mode %Standard% prendra simplement une chaîne, l'encodera en UTF-8 et l'enverra dans le corps de la requête. Le champ %Content Type% sera automatiquement converti en un en-tête %Content-Type% et ajouté à la demande.</value>
  </data>
  <data name="Help1x02" xml:space="preserve">
    <value>Le mode %Raw% fait essentiellement la même chose que le mode Standard si votre contenu est un tableau d'octets et non une chaîne. Le %Auth de base% est utilisé pour l'authentification avec l'authentification d'accès de base (la fenêtre contextuelle typique de nom d'utilisateur / mot de passe que vous voyez dans votre navigateur demandant des informations d'identification). Enfin, le mode %Multipart% enverra un contenu qui peut être composé de plusieurs parties, comme des chaînes, des octets bruts et des fichiers. Ceci est utile par exemple pour télécharger un fichier sur un site Web.</value>
  </data>
  <data name="Help1x03" xml:space="preserve">
    <value>La réponse sera analysée et divisée en morceaux qui seront affectés à différentes variables par défaut. La réponse %Address% (après la dernière redirection si vous avez activé %Auto Redirect%) sera enregistrée dans la variable String `data.ADDRESS`. La réponse %body% (a.k.a source) sera à l'intérieur de la variable String `data.SOURCE` (sous forme de chaîne UTF-8), et à l'intérieur de la variable Byte Array `data.RAWSOURCE` (après décompression de par exemple gzip).</value>
  </data>
  <data name="Help1x04" xml:space="preserve">
    <value>Le %Code de réponse% (par exemple 200) sera inséré dans la variable Entier `data.RESPONSECODE`. Les en-têtes seront analysés dans un dictionnaire et insérés dans la variable Dictionary of Strings `data.HEADERS`, et de même pour les cookies dans la variable `data.COOKIES`. N'oubliez pas que vous pouvez facilement récupérer les valeurs des dictionnaires par clé avec la syntaxe `data.HEADERS [" header-name "]`. Si la requête échoue, la variable `data.STATUS` sera définie sur` ERROR`.</value>
  </data>
  <data name="Help1x05" xml:space="preserve">
    <value>Une dernière chose à retenir est que les cookies à l'intérieur de la variable `data.COOKIES` sont uniquement ajoutés ou écrasés, jamais supprimés. Cela signifie que les cookies précédemment reçus (qui sont à l'intérieur de la variable `data.COOKIES`) seront à nouveau envoyés dans les requêtes suivantes, en plus des %Cookies personnalisés% que vous pouvez définir pour chaque nouvelle requête. Cela se produit à moins que «data.COOKIES» ne soit effacé ou réinitialisé.</value>
  </data>
  <data name="Hide" xml:space="preserve">
    <value>Cacher</value>
  </data>
  <data name="Label" xml:space="preserve">
    <value>Label</value>
  </data>
  <data name="Settings" xml:space="preserve">
    <value>Réglages</value>
  </data>
  <data name="Show" xml:space="preserve">
    <value>Afficher</value>
  </data>
</root>